<!doctype html><html lang=pt-br><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile - Blog do Prof</title><meta name=Description content="Kotlin, Golang e outras coisas que achar interessantes!"><meta property="og:title" content="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile"><meta property="og:description" content="O Docker se tornou a referência de facto quando falamos em contêineres. Como resultado, a prática de criar um contêiner (do inglês container) de uma aplicação que está sendo desenvolvida através de um arquivo Dockerfile tornou-se uma habilidade valorizada no desenvolvimento de software moderno.
Logo, o objetivo desta postagem é como definir um arquivo Dockerfile de uma aplicação desenvolvida em Kotlin com o gerenciador de projeto Gradle.
O que é um Dockerfile?"><meta property="og:type" content="article"><meta property="og:url" content="http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/"><meta property="og:image" content="http://brunolopesjn.dev.br/img/bruno.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-10T15:22:26-03:00"><meta property="article:modified_time" content="2023-12-10T15:22:26-03:00"><meta property="og:site_name" content="Blog do Prof"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://brunolopesjn.dev.br/img/bruno.png"><meta name=twitter:title content="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile"><meta name=twitter:description content="O Docker se tornou a referência de facto quando falamos em contêineres. Como resultado, a prática de criar um contêiner (do inglês container) de uma aplicação que está sendo desenvolvida através de um arquivo Dockerfile tornou-se uma habilidade valorizada no desenvolvimento de software moderno.
Logo, o objetivo desta postagem é como definir um arquivo Dockerfile de uma aplicação desenvolvida em Kotlin com o gerenciador de projeto Gradle.
O que é um Dockerfile?"><meta name=application-name content="Blog do Prof"><meta name=apple-mobile-web-app-title content="Blog do Prof"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/><link rel=stylesheet href=/css/style.min.cf6878db51c51b2d04ae155284a4403dbee8db33e16c066f954c95279c271fcd.css integrity="sha256-z2h421HFGy0ErhVShKRAPb7o2zPhbAZvlUyVJ5wnH80="><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile","inLanguage":"pt-br","mainEntityOfPage":{"@type":"WebPage","@id":"http:\/\/brunolopesjn.dev.br\/posts\/20231210_criando-imagem-docker-projetos-kotlin-gradle\/"},"genre":"posts","keywords":"Kotlin, Gradle, Docker","wordcount":1754,"url":"http:\/\/brunolopesjn.dev.br\/posts\/20231210_criando-imagem-docker-projetos-kotlin-gradle\/","datePublished":"2023-12-10T15:22:26-03:00","dateModified":"2023-12-10T15:22:26-03:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Bruno Lopes"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Blog do Prof">Blog do Prof</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Postagens </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categorias </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Trocar tema">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Blog do Prof">Blog do Prof</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Postagens</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categorias</a><a href=javascript:void(0); class="menu-item theme-switch" title="Trocar tema">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Conteúdos</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Bruno Lopes</a></span>&nbsp;<span class=post-category>incluido em <a href=/categories/kotlin/><i class="far fa-folder fa-fw" aria-hidden=true></i>Kotlin</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=10/12/2023>10/12/2023</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1754 palavras&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutos&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png data-srcset="/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png, /img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png 1.5x, /img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png 2x" data-sizes=auto alt=/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png title=/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Conteúdos</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static></div></div><div class=content id=content><div class=paragraph><p>O <em>Docker</em> se tornou a referência <em>de facto</em> quando falamos em contêineres. Como resultado, a prática de criar um contêiner (do inglês <em>container</em>) de uma aplicação que está sendo desenvolvida através de um arquivo <strong>Dockerfile</strong> tornou-se uma habilidade valorizada no desenvolvimento de software moderno.</p></div><div class=paragraph><p>Logo, o objetivo desta postagem é como definir um arquivo <em>Dockerfile</em> de uma aplicação desenvolvida em <strong>Kotlin</strong> com o gerenciador de projeto <strong>Gradle</strong>.</p></div><div class=sect1><h2 id=_o_que_é_um_dockerfile>O que é um Dockerfile?</h2><div class=sectionbody><div class=paragraph><p>O <em>Dockerfile</em> é um arquivo de texto plano que contém um conjunto de instruções para a construção do código fonte para, em seguida, empacotar em um imagem <em>Docker</em>. Em outras palavras, é uma maneira de criar uma imagem <em>Docker</em> com uma versão compilada e funcional do código que você está desenvolvendo.</p></div><div class=paragraph><p>A vantagem de empacotar sua aplicação em uma imagem <em>Docker</em> através de um <em>Dockerfile</em> é a capacidade de versionar (já que é um arquivo de texto plano), de compartilhar com outras pessoas e principalmente de sempre gerar uma imagem idêntica a cada construção, ou seja, todas as pessoas que executarem o <em>Dockerfile</em> obterão o mesmo resultado.</p></div></div></div><div class=sect1><h2 id=_escrevendo_um_dockerfile>Escrevendo um Dockerfile</h2><div class=sectionbody><div class=paragraph><p>Para escrever um <em>Dockerfile</em> bas ta utilizar um editor de texto de sua preferência (nessa postagem estou utilizando o <strong>VSCodium</strong>).</p></div><div class=paragraph><p>Primeiro, deve-se criar um arquivo de texto de nome <em>Dockerfile</em> na raiz do seu projeto. Dentro deste arquivo, serão colocadas as instruções necessárias para construção do código fonte e, posteriormente, do empacotamento do resultado em uma imagem <em>Docker</em>.</p></div><div class=paragraph><p>As instruções <em>Dockerfile</em> mais comuns são:</p></div><div class=ulist><ul><li><p><strong>FROM &lt;imagem></strong>: Define a imagem base que será utilizada como ponto de partida para a construção da sua imagem <em>Docker</em>. Por exemplo, o trecho <code>FROM debian:12.2</code> está definindo que a nossa imagem <em>Docker</em> base será construída sobre a imagem <em>Docker</em> do <strong>Debian 12.2</strong>;</p></li><li><p><strong>RUN &lt;comando></strong>: Executa qualquer comando a partir da imagem <em>Docker</em> base criando um novo volume de dados sobre ela. Por exemplo, o trecho <code>RUN apt update</code> irá executar o comando <code>apt update</code> dentro da imagem durante o processo de construção;</p></li><li><p><strong>WORKDIR &lt;diretório></strong>: Configura o diretório de trabalho (diretório da imagem base em que os comandos serão executados) para as instruções <strong>RUN</strong>, <strong>CMD</strong>, <strong>ENTRYPOINT</strong>, <strong>COPY</strong> e <strong>ADD</strong> logo após a definição do <strong>WORKDIR</strong>. Por exemplo, o trecho <code>WORKDIR /app</code> indica que as próximas instruções <strong>RUN</strong>, <strong>CMD</strong>, <strong>ENTRYPOINT</strong>, <strong>COPY</strong> e <strong>ADD</strong> serão executadas dentro do diretório <code>/app</code>;</p></li><li><p><strong>COPY &lt;origem> &lt;destino></strong>: Copia arquivos e diretórios da origem (seu computador) e os adiciona no diretório de destino dentro do contêiner. Por exemplo, o trecho <code>COPY . /app</code> irá copiar todos os arquivos e diretórios do seu computador, tomando como base o diretório atual do arquivo <em>Dockerfile</em>, para a pasta <code>/app</code> do contêiner;</p></li><li><p><strong>EXPOSE &lt;port></strong>: Essa instrução indica ao <em>Docker</em> que o contêiner está ouvindo (aguardando requisições) da porta de rede especificada durante sua execução. Por exemplo, o trecho <code>EXPOSE 8080</code> está definindo que o contêiner gerado a partir do <em>Dockerfile</em> irá aguardar por conexões externas na porta de rede <code>8080</code>.</p></li><li><p><strong>CMD &lt;comando></strong>: Define qual será o programa que será executado uma vez que o contêiner baseado no seu <strong>Dockerfile</strong> ser inicializado. Cada arquivo <em>Dockerfile</em> deveria possui apenas uma instrução <strong>CMD</strong>. Caso existam duas ou mais entradas <strong>CMD</strong>, apenas a última declaração será respeitada.</p></li></ul></div></div></div><div class=sect1><h2 id=_construção_de_múltiplos_estágios>Construção de múltiplos estágios</h2><div class=sectionbody><div class=paragraph><p>O tamanho final da imagem <em>Docker</em> criada a partir de um <em>Dockerfile</em> pode, a depender do contexto, ser tomado como um indicador de qualidade da imagem. Logo imagens com tamanho pequeno (a definição de pequeno muda de acordo com o contexto) são mais valorizadas.</p></div><div class=paragraph><p>Também, no processo de construção da aplicação são utilizadas algumas bibliotecas e ferramentas que, após o processo de construção, não são mais necessárias para a sua execução.</p></div><div class=paragraph><p>Por exemplo, podemos citar um projeto Kotlin que necessita de um gerenciador de projeto (Gradle, Mavem, etc) para construir o projeto, ou seja, gerar o <strong>.jar</strong> executável do projeto. Contudo, após possuir o arquivo <strong>.jar</strong> não se faz necessário possuir um gerenciador de projeto, uma <strong>JDK</strong> (<em>Java Development Kit</em>) e outras ferramentas, apenas será necessário um ambiente com o <strong>JRE</strong> (<em>Java Runtime Environment</em>).</p></div><div class=paragraph><p>Assim, seria interessante dividirmos o processo de criação da imagem em dois momentos distintos:</p></div><div class="olist arabic"><ol class=arabic><li><p><strong>Construção do projeto</strong>: Geração do arquivo executável do projeto (no caso do Kotlin o <strong>.jar</strong>);</p></li><li><p><strong>Criação da imagem</strong>: Criação da imagem docker final com o executável do projeto e o ambiente de execução (no caso do Kotlin a <strong>JRE</strong>).</p></li></ol></div><div class=paragraph><p>Pensando nessa situação, existem os <strong>multi-stages build</strong> ou, traduzindo para o português, <strong>construção em múltiplos estágios</strong>. Além de organizamos o processo de construção em partes separadas, também, a depender da situação, podemos acelerar o processo de construção ao utilizar melhor o mecanismo de <strong>cache</strong> que o <em>Docker</em> utiliza ao construir uma imagem (se uma parte da construção não sofre mudanças, pode-se utilizar a versão armazenada em <strong>cache</strong> em construções futuras).</p></div><div class=paragraph><p>Para utilizar a construção de múltiplos estágios, basta definirmos duas ou mais instruções <strong>FROM</strong> no arquivo <em>Dockerfile</em>. Cada instrução <strong>FROM</strong> será tratada como um estágio de construção no processo de geração da imagem <em>Docker</em> onde cada estágio será executado em contêiner separado. As instruções que estiverem após o ultimo <strong>FROM</strong> no arquivo <em>Dockerfile</em> é serão as instruções utilizadas para gerar a imagem resultante do processo.</p></div><div class=paragraph><p>Por exemplo, no exemplo de <em>Dockerfile</em> a seguir está sendo definido uma construção de múltiplos estágios para a construção de uma imagem <em>Docker</em> com um <code>hello, world</code> em <em>Golang</em>:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=docker><span class=k>FROM</span><span class=w> </span><span class=s>golang:1.21</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=s>build </span><i class=conum data-value=1></i><b>(1)</b>
<span class=k>WORKDIR</span><span class=s> /src</span>
<span class=k>COPY</span><span class=s> &lt;&lt;EOF /src/main.go </span><i class=conum data-value=2></i><b>(2)</b>
package main

import &#34;fmt&#34;

func main() {
  fmt.Println(&#34;hello, world&#34;)
}
EOF
<span class=k>RUN </span>go build <span class=nt>-o</span> /bin/hello ./main.go <i class=conum data-value=3></i><b>(3)</b>

<span class=k>FROM</span><span class=s> scratch </span><i class=conum data-value=4></i><b>(4)</b>
<span class=k>COPY</span><span class=s> --from=build /bin/hello /bin/hello </span><i class=conum data-value=5></i><b>(5)</b>
<span class=k>CMD</span><span class=s> [&#34;/bin/hello&#34;]</span></code></pre></div></div><div class="colist arabic"><table><tbody><tr><td><i class=conum data-value=1></i><b>1</b></td><td>Está sendo definido uma imagem <em>Docker</em> que possui o <em>Golang</em> versão <em>1.21</em> instalado. Esse é o primeiro estágio do processo de construção e possui o nome <code>build</code> por conta do uso palavra chave <strong>as</strong></td></tr><tr><td><i class=conum data-value=2></i><b>2</b></td><td>Criando o arquivo <code>/src/main.go</code> dentro do container com o código necessário para executar o <code>hello, world</code></td></tr><tr><td><i class=conum data-value=3></i><b>3</b></td><td>Processo de compilação do código fonte <em>Golang</em> em um executável.</td></tr><tr><td><i class=conum data-value=4></i><b>4</b></td><td>Aqui inicia-se o segundo estágio da construção que utilizará uma imagem <em>Docker</em> chamada <em>scratch</em> a qual possui uma versão minimalista do <em>Linux</em>.</td></tr><tr><td><i class=conum data-value=5></i><b>5</b></td><td>O executável resultante de &lt;3> é copiado do diretório <code>/bin/hello</code> do contêiner utilizado no primeiro estágio, chamado <strong>build</strong> (--from=build), para o diretório <code>/bin/hello</code> do contêiner do segundo estágio.</td></tr></tbody></table></div></div></div><div class=sect1><h2 id=_escrevendo_o_dockerfile_para_projetos_kotlin_com_gradle>Escrevendo o Dockerfile para projetos Kotlin com Gradle</h2><div class=sectionbody><div class=paragraph><p>Agora temos tudo o que é necessário para construirmos o <em>Dockerfile</em> para um projeto Kotlin com Gradle. Vale ressaltar que é necessário ter o plugin <a href=https://imperceptiblethoughts.com/shadow/><strong>shadowJar</strong></a> devidamente configurado no <em>Gradle</em> para gerar o arquivo <strong>.jar</strong> do projeto Kotlin.</p></div><div class=paragraph><div class="details admonition info open"><div class="details-summary admonition-title"><i class="icon fas fa-info-circle fa-fw" aria-hidden=true></i>Projetos Kotlin<i class="details-icon fas fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content><div class=paragraph><p>Quando fala-se em projetos <em>Kotlin</em> nesta postagem, está sendo falado de qualquer projeto <em>Kotlin</em> que pode ser construído <em>Gradle</em> como, por exemplo, um projeto <strong>Spring</strong>, um projeto <strong>Micronaut</strong> ou qualquer outro projeto <em>Kotlin</em> que utilize qualquer outro <em>framework</em> com mo <em>Gradle</em>.</p></div><div class=paragraph><p>Isso se deve ao fato do plugin <a href=https://imperceptiblethoughts.com/shadow/><strong>shadowJar</strong></a> saber como gerar o arquivo <strong>.jar</strong> de projetos <em>Kotlin</em> gerenciados pelo <em>Gradle</em> independente do <em>framework</em> utilizado.</p></div></div></div></div></div><div class=paragraph><p>O modelo de <em>Dockerfile</em> a seguir pode ser utilizado para construir uma imagem de um projeto <em>Kotlin</em> com <em>Gradle</em>:</p></div><div id=modelo class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=docker><span class=c># Processo de compilação</span>
<span class=k>FROM</span><span class=w> </span><span class=s>gradle:8.4.0-jdk17-alpine</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=s>build</span>
<span class=k>COPY</span><span class=s> . /app</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=k>RUN </span>gradle <span class=nt>--no-daemon</span> shadowJar

<span class=c># Processo de criação da imagem final</span>
<span class=k>FROM</span><span class=s> alpine:3.18.4</span>
<span class=k>RUN </span>apk update <span class=o>&amp;&amp;</span> apk upgrade <span class=se>\
</span> <span class=o>&amp;&amp;</span> apk add <span class=nt>--no-cache</span> openjdk17-jre

<span class=k>EXPOSE</span><span class=s> 8080</span>
<span class=k>COPY</span><span class=s> --from=build /app/build/libs/&lt;nome-arquivo-compilado&gt;.jar /bin/runner/run.jar</span>

<span class=k>WORKDIR</span><span class=s> /bin/runner</span>
<span class=k>CMD</span><span class=s> [&#34;java&#34;,&#34;-jar&#34;, &#34;run.jar&#34;]</span></code></pre></div></div><div class=paragraph><p>Vamos dividir o modelo de <em>Dockerfile</em> acima em dois blocos para facilitar a explicação.</p></div><div class=sect2><h3 id=_explicação_do_primeiro_bloco>Explicação do primeiro bloco</h3><div class=paragraph><p>No primeiro bloco temos as seguintes instruções:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=docker><span class=c># Processo de compilação</span>
<span class=k>FROM</span><span class=w> </span><span class=s>gradle:8.4.0-jdk17-alpine</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=s>build</span>
<span class=k>COPY</span><span class=s> . /app</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=k>RUN </span>gradle <span class=nt>--no-daemon</span> shadowJar</code></pre></div></div><div class=paragraph><p>Primero é definido uma instrução <strong>FROM</strong> que utilizará a imagem <a href=https://hub.docker.com/ class=bare>https://hub.docker.com/</a><em>/gradle[<code>gradle:8.4.0-jdk17-alpine</code>] que possui o _Gradle</em> versão <em>8.4.0</em> instalado com o <em>JDK 17</em> em um <em>Alpine Linux</em>. Como está sendo utilizado o processo de construção de múltiplos estágios, esse primeiro estágio está recebendo o nome de <strong>build</strong></p></div><div class=paragraph><p>Em seguida, a instrução <strong>COPY</strong> realiza a cópia de todos os arquivos e sub-diretório a partir do diretório em que se encontra o arquivo <em>Dockerfile</em>. Logo esse arquivo deve ser criado na raiz do projeto para que, durante o processo de construção da imagem <em>Docker</em> ele seja capaz de copiar todos os arquivos e diretórios do projeto para dentro da imagem.</p></div><div class=paragraph><p>A instrução <strong>WORKDIR</strong> define que o diretório de trabalho passará a ser o diretório <code>/app</code>, ou seja, as instruções <strong>RUN</strong>, <strong>CMD</strong>, <strong>ENTRYPOINT</strong>, <strong>COPY</strong> e <strong>ADD</strong> definidas após <strong>WORKDIR</strong> serão executadas tomando como base o diretório <code>/app</code>.</p></div><div class=paragraph><p>Por fim, a instrução <strong>RUN</strong> executa uma tarefa <em>Gradle</em> chamada <strong>shadowJar</strong>, a qual é responsável por gerar o arquivo <strong>.jar</strong> do projeto dentro da pasta <code>/app/build/libs/&lt;nome-projeto>-&lt;valor-version>-all.jar</code>, onde <strong>&lt;nome-projeto></strong> é o nome do projeto Kotlin que foi dado no momento da criação do mesmo e <strong>&lt;valor-version></strong> é o valor da variável <strong>VERSION</strong> que está presente no arquivo <code>build.gradle</code>.</p></div></div><div class=sect2><h3 id=_explicação_do_segundo_bloco>Explicação do segundo bloco</h3><div class=paragraph><p>O segundo bloco é formado pelas seguintes instruções:</p></div><div class=listingblock><div class=content><pre class="rouge highlight"><code data-lang=docker><span class=c># Processo de criação da imagem final</span>
<span class=k>FROM</span><span class=s> alpine:3.18.4</span>
<span class=k>RUN </span>apk update <span class=o>&amp;&amp;</span> apk upgrade <span class=se>\
</span> <span class=o>&amp;&amp;</span> apk add <span class=nt>--no-cache</span> openjdk17-jre

<span class=k>EXPOSE</span><span class=s> 8080</span>
<span class=k>COPY</span><span class=s> --from=build /app/build/libs/&lt;nome-arquivo-compilado&gt;.jar /bin/runner/run.jar</span>

<span class=k>WORKDIR</span><span class=s> /bin/runner</span>
<span class=k>CMD</span><span class=s> [&#34;java&#34;, &#34;-jar&#34;, &#34;run.jar&#34;]</span></code></pre></div></div><div class=paragraph><p>Primeiro é definido uma instrução <strong>FROM</strong> que utilizará a imagem <a href=https://hub.docker.com/ class=bare>https://hub.docker.com/</a><em>/alpine[<code>Alpine Linux</code>] versão _3.18.4</em> que possui apenas o sistema base, ou seja, uma instalação limpa da distribuição <em>Alpine Linux</em></p></div><div class=paragraph><p>Na instrução <strong>RUN</strong> está sendo realizado uma atualização das bases de dados de pacotes da distribuição (<strong>apk update</strong>), seguido de uma atualização dos programas instalados (<strong>apk upgrade</strong>) e, por fim, a instalação da <em>JRE</em> (<strong>apk add --no-cache openjdk17-jre</strong>). Vale ressaltar que os símbolos duplos <strong>&&</strong> entre os comandos indicam que eles serão executados de forma encadeada.</p></div><div class=paragraph><p>A instrução <strong>EXPOSE</strong> está definindo que o contêiner resultante espera receber requisições na porta <strong>8080</strong>.</p></div><div class=paragraph><p>Nesse ponto, a instrução <strong>COPY</strong> irá copiar o arquivo <strong>.jar</strong> gerado no estágio anterior (através da instrução <code>RUN gradle --no-daemon shadowJar</code>) para o diretório <code>/bin/runner/run.jar</code>, onde <code>run.jar</code> será o novo nome do arquivo <strong>.jar</strong>. Lembrando que o trecho <code>--from=build</code> indica que o diretório de origem está no container do estágio chamado <strong>build</strong>.</p></div><div class=paragraph><p>Já a instrução <strong>WORKDIR</strong> está definindo o diretório <code>/bin/runner</code> como diretório de trabalho.</p></div><div class=paragraph><p>E, por fim, a instrução <strong>CMD</strong> está definindo o comando para inicializar o projeto <em>Kotlin</em> via o arquivo <strong>.jar</strong>, ou seja, entre os colchetes são definidos os parâmetros do comando que será executado no final, resultando em <code>java -jar run.jar</code>.</p></div></div></div></div><div class=sect1><h2 id=_conclusão>Conclusão</h2><div class=sectionbody><div class=paragraph><p>Ao utilizar o <a href=#modelo>modelo</a> <em>Dockerfile</em> proposto neste artigo, você será capaz de empacotar ser projeto <em>Kotlin</em> com <em>Gradle</em> em um contêiner <em>Docker</em>. Qualquer dúvida ou sugestão peço, por gentileza que entre em contato comigo em uma das minhas redes sociais.</p></div><div class=paragraph><p>Até a próxima!</p></div></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Atualizado em 10/12/2023</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Compartilhe em Twitter" data-sharer=twitter data-url=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/ data-title="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile" data-via=profbrunolopes data-hashtags=Kotlin,Gradle,Docker><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Compartilhe em Linkedin" data-sharer=linkedin data-url=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/><i class="fab fa-linkedin fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Compartilhe em WhatsApp" data-sharer=whatsapp data-url=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/ data-title="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile" data-web><i class="fab fa-whatsapp fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Compartilhe em Hacker News" data-sharer=hackernews data-url=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/ data-title="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Compartilhe em 微博" data-sharer=weibo data-url=http://brunolopesjn.dev.br/posts/20231210_criando-imagem-docker-projetos-kotlin-gradle/ data-title="Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile" data-image=/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/kotlin/>Kotlin</a>,&nbsp;<a href=/tags/gradle/>Gradle</a>,&nbsp;<a href=/tags/docker/>Docker</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Voltar</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav></div></div><div id=comments><div id=disqus_thread class=comment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://disqus.com/?ref_noscript>Disqus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Possibilitado por <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.119.0">Hugo</a> | Tema - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Bruno Lopes</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Voltar ao topo"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="Ver comentários"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://https-profbrunolopes-dev-br.disqus.com.disqus.com/embed.js defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copiar para a área de transferência",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.b0df51c2c57145081cc73960e9aa780e6f5f56d06cf4ef0f96da8ce1619d1e12.js integrity="sha256-sN9RwsVxRQgcxzlg6ap4Dm9fVtBs9O8PltqM4WGdHhI="></script></body></html>