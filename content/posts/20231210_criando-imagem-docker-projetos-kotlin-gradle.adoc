---
title: "Criando uma imagem Docker de projetos Kotlin com Gradle com Dockerfile"
date: 2023-12-10T15:22:26-03:00
draft: false

author: "Bruno Lopes"
categories: [Kotlin]
tags: [Kotlin, Gradle, Docker]
featuredImage: "/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png"
featuredImagePreview: "/img/20231210_criando-imagem-docker-projetos-kotlin-gradle.png"
---

:icons: font
:source-highlighter: rouge

O _Docker_ se tornou a referência _de facto_ quando falamos em contêineres. Como resultado, a prática de criar um contêiner (do inglês _container_) de uma aplicação que está sendo desenvolvida através de um arquivo *Dockerfile* tornou-se uma habilidade valorizada no desenvolvimento de software moderno.

Logo, o objetivo desta postagem é como definir um arquivo _Dockerfile_ de uma aplicação desenvolvida em *Kotlin* com o gerenciador de projeto *Gradle*.

== O que é um Dockerfile?

O _Dockerfile_ é um arquivo de texto plano que contém um conjunto de instruções para a construção do código fonte para, em seguida, empacotar em um imagem _Docker_. Em outras palavras, é uma maneira de criar uma imagem _Docker_ com uma versão compilada e funcional do código que você está desenvolvendo.

A vantagem de empacotar sua aplicação em uma imagem _Docker_ através de um _Dockerfile_ é a capacidade de versionar (já que é um arquivo de texto plano), de compartilhar com outras pessoas e principalmente de sempre gerar uma imagem idêntica a cada construção, ou seja, todas as pessoas que executarem o _Dockerfile_ obterão o mesmo resultado.

== Escrevendo um Dockerfile

Para escrever um _Dockerfile_ bas ta utilizar um editor de texto de sua preferência (nessa postagem estou utilizando o *VSCodium*).

Primeiro, deve-se criar um arquivo de texto de nome _Dockerfile_ na raiz do seu projeto. Dentro deste arquivo, serão colocadas as instruções necessárias para construção do código fonte e, posteriormente, do empacotamento do resultado em uma imagem _Docker_. 

As instruções _Dockerfile_ mais comuns são:

* *FROM <imagem>*: Define a imagem base que será utilizada como ponto de partida para a construção da sua imagem _Docker_. Por exemplo, o trecho `FROM debian:12.2` está definindo que a nossa imagem _Docker_ base será construída sobre a imagem _Docker_ do *Debian 12.2*;
* *RUN <comando>*: Executa qualquer comando a partir da imagem _Docker_ base criando um novo volume de dados sobre ela. Por exemplo, o trecho `RUN apt update` irá executar o comando `apt update` dentro da imagem durante o processo de construção;
* *WORKDIR <diretório>*: Configura o diretório de trabalho (diretório da imagem base em que os comandos serão executados) para as instruções *RUN*, *CMD*, *ENTRYPOINT*, *COPY* e *ADD* logo após a definição do *WORKDIR*. Por exemplo, o trecho `WORKDIR /app` indica que as próximas instruções *RUN*, *CMD*, *ENTRYPOINT*, *COPY* e *ADD* serão executadas dentro do diretório `/app`;
* *COPY <origem> <destino>*: Copia arquivos e diretórios da origem (seu computador) e os adiciona no diretório de destino dentro do contêiner. Por exemplo, o trecho `COPY . /app` irá copiar todos os arquivos e diretórios do seu computador, tomando como base o diretório atual do arquivo _Dockerfile_, para a pasta `/app` do contêiner;
* *EXPOSE <port>*: Essa instrução indica ao _Docker_ que o contêiner está ouvindo (aguardando requisições) da porta de rede especificada durante sua execução. Por exemplo, o trecho `EXPOSE 8080` está definindo que o contêiner gerado a partir do _Dockerfile_ irá aguardar por conexões externas na porta de rede `8080`.
* *CMD <comando>*: Define qual será o programa que será executado uma vez que o contêiner baseado no seu *Dockerfile* ser inicializado. Cada arquivo _Dockerfile_ deveria possui apenas uma instrução *CMD*. Caso existam duas ou mais entradas *CMD*, apenas a última declaração será respeitada.

== Construção de múltiplos estágios

O tamanho final da imagem _Docker_ criada a partir de um _Dockerfile_ pode, a depender do contexto, ser tomado como um indicador de qualidade da imagem. Logo imagens com tamanho pequeno (a definição de pequeno muda de acordo com o contexto) são mais valorizadas.

Também, no processo de construção da aplicação são utilizadas algumas bibliotecas e ferramentas que, após o processo de construção, não são mais necessárias para a sua execução.

Por exemplo, podemos citar um projeto Kotlin que necessita de um gerenciador de projeto (Gradle, Mavem, etc) para construir o projeto, ou seja, gerar o *.jar* executável do projeto. Contudo, após possuir o arquivo *.jar* não se faz necessário possuir um gerenciador de projeto, uma *JDK* (_Java Development Kit_) e outras ferramentas, apenas será necessário um ambiente com o *JRE* (_Java Runtime Environment_).

Assim, seria interessante dividirmos o processo de criação da imagem em dois momentos distintos:

1. *Construção do projeto*: Geração do arquivo executável do projeto (no caso do Kotlin o *.jar*);
2. *Criação da imagem*: Criação da imagem docker final com o executável do projeto e o ambiente de execução (no caso do Kotlin a *JRE*).

Pensando nessa situação, existem os *multi-stages build* ou, traduzindo para o português, *construção em múltiplos estágios*. Além de organizamos o processo de construção em partes separadas, também, a depender da situação, podemos acelerar o processo de construção ao utilizar melhor o mecanismo de *cache* que o _Docker_ utiliza ao construir uma imagem (se uma parte da construção não sofre mudanças, pode-se utilizar a versão armazenada em *cache* em construções futuras).

Para utilizar a construção de múltiplos estágios, basta definirmos duas ou mais instruções *FROM* no arquivo _Dockerfile_. Cada instrução *FROM* será tratada como um estágio de construção no processo de geração da imagem _Docker_ onde cada estágio será executado em contêiner separado. As instruções que estiverem após o ultimo *FROM* no arquivo _Dockerfile_ é serão as instruções utilizadas para gerar a imagem resultante do processo.

Por exemplo, no exemplo de _Dockerfile_ a seguir está sendo definido uma construção de múltiplos estágios para a construção de uma imagem _Docker_ com um `hello, world` em _Golang_:

[source, docker]
----
FROM golang:1.21 as build <1>
WORKDIR /src
COPY <<EOF /src/main.go <2>
package main

import "fmt"

func main() {
  fmt.Println("hello, world")
}
EOF
RUN go build -o /bin/hello ./main.go <3>

FROM scratch <4>
COPY --from=build /bin/hello /bin/hello <5>
CMD ["/bin/hello"]
----
<1> Está sendo definido uma imagem _Docker_ que possui o _Golang_ versão _1.21_ instalado. Esse é o primeiro estágio do processo de construção e possui o nome `build` por conta do uso palavra chave *as*
<2> Criando o arquivo `/src/main.go` dentro do container com o código necessário para executar o `hello, world`
<3> Processo de compilação do código fonte _Golang_ em um executável.
<4> Aqui inicia-se o segundo estágio da construção que utilizará uma imagem _Docker_ chamada _scratch_ a qual possui uma versão minimalista do _Linux_.
<5> O executável resultante de <3> é copiado do diretório `/bin/hello` do contêiner utilizado no primeiro estágio, chamado *build* (--from=build), para o diretório `/bin/hello` do contêiner do segundo estágio.

== Escrevendo o Dockerfile para projetos Kotlin com Gradle

Agora temos tudo o que é necessário para construirmos o _Dockerfile_ para um projeto Kotlin com Gradle. Vale ressaltar que é necessário ter o plugin https://imperceptiblethoughts.com/shadow/[*shadowJar*] devidamente configurado no _Gradle_ para gerar o arquivo *.jar* do projeto Kotlin.

{{< admonition type=info title="Projetos Kotlin" open=true >}}
Quando fala-se em projetos _Kotlin_ nesta postagem, está sendo falado de qualquer projeto _Kotlin_ que pode ser construído _Gradle_ como, por exemplo, um projeto *Spring*, um projeto *Micronaut* ou qualquer outro projeto _Kotlin_ que utilize qualquer outro _framework_ com mo _Gradle_.

Isso se deve ao fato do plugin https://imperceptiblethoughts.com/shadow/[*shadowJar*] saber como gerar o arquivo *.jar* de projetos _Kotlin_ gerenciados pelo _Gradle_ independente do _framework_ utilizado.
{{< /admonition >}}

O modelo de _Dockerfile_ a seguir pode ser utilizado para construir uma imagem de um projeto _Kotlin_ com _Gradle_:

[#modelo, docker]
----
# Processo de compilação
FROM gradle:8.4.0-jdk17-alpine as build
COPY . /app
WORKDIR /app
RUN gradle --no-daemon shadowJar

# Processo de criação da imagem final
FROM alpine:3.18.4
RUN apk update && apk upgrade \
 && apk add --no-cache openjdk17-jre

EXPOSE 8080
COPY --from=build /app/build/libs/<nome-arquivo-compilado>.jar /bin/runner/run.jar

WORKDIR /bin/runner
CMD ["java","-jar", "run.jar"]
----

Vamos dividir o modelo de _Dockerfile_ acima em dois blocos para facilitar a explicação. 

=== Explicação do primeiro bloco

No primeiro bloco temos as seguintes instruções:

[source, docker]
----
# Processo de compilação
FROM gradle:8.4.0-jdk17-alpine as build
COPY . /app
WORKDIR /app
RUN gradle --no-daemon shadowJar
----

Primero é definido uma instrução *FROM* que utilizará a imagem https://hub.docker.com/_/gradle[`gradle:8.4.0-jdk17-alpine`] que possui o _Gradle_ versão _8.4.0_ instalado com o _JDK 17_ em um _Alpine Linux_. Como está sendo utilizado o processo de construção de múltiplos estágios, esse primeiro estágio está recebendo o nome de *build*

Em seguida, a instrução *COPY* realiza a cópia de todos os arquivos e sub-diretório a partir do diretório em que se encontra o arquivo _Dockerfile_. Logo esse arquivo deve ser criado na raiz do projeto para que, durante o processo de construção da imagem _Docker_ ele seja capaz de copiar todos os arquivos e diretórios do projeto para dentro da imagem.

A instrução *WORKDIR* define que o diretório de trabalho passará a ser o diretório `/app`, ou seja, as instruções *RUN*, *CMD*, *ENTRYPOINT*, *COPY* e *ADD* definidas após *WORKDIR* serão executadas tomando como base o diretório `/app`.

Por fim, a instrução *RUN* executa uma tarefa _Gradle_ chamada *shadowJar*, a qual é responsável por gerar o arquivo *.jar* do projeto dentro da pasta `/app/build/libs/<nome-projeto>-<valor-version>-all.jar`, onde *<nome-projeto>* é o nome do projeto Kotlin que foi dado no momento da criação do mesmo e *<valor-version>* é o valor da variável *VERSION* que está presente no arquivo `build.gradle`.

=== Explicação do segundo bloco

O segundo bloco é formado pelas seguintes instruções:

[source, docker]
----
# Processo de criação da imagem final
FROM alpine:3.18.4
RUN apk update && apk upgrade \
 && apk add --no-cache openjdk17-jre

EXPOSE 8080
COPY --from=build /app/build/libs/<nome-arquivo-compilado>.jar /bin/runner/run.jar

WORKDIR /bin/runner
CMD ["java", "-jar", "run.jar"]
----

Primeiro é definido uma instrução *FROM* que utilizará a imagem https://hub.docker.com/_/alpine[`Alpine Linux`] versão _3.18.4_ que possui apenas o sistema base, ou seja, uma instalação limpa da distribuição _Alpine Linux_

Na instrução *RUN* está sendo realizado uma atualização das bases de dados de pacotes da distribuição (*apk update*), seguido de uma atualização dos programas instalados (*apk upgrade*) e, por fim, a instalação da _JRE_ (*apk add --no-cache openjdk17-jre*). Vale ressaltar que os símbolos duplos *&&* entre os comandos indicam que eles serão executados de forma encadeada.

A instrução *EXPOSE* está definindo que o contêiner resultante espera receber requisições na porta *8080*.

Nesse ponto, a instrução *COPY* irá copiar o arquivo *.jar* gerado no estágio anterior (através da instrução `RUN gradle --no-daemon shadowJar`) para o diretório `/bin/runner/run.jar`, onde `run.jar` será o novo nome do arquivo *.jar*. Lembrando que o trecho `--from=build` indica que o diretório de origem está no container do estágio chamado *build*.

Já a instrução *WORKDIR* está definindo o diretório `/bin/runner` como diretório de trabalho.

E, por fim, a instrução *CMD* está definindo o comando para inicializar o projeto _Kotlin_ via o arquivo *.jar*, ou seja, entre os colchetes são definidos os parâmetros do comando que será executado no final, resultando em `java -jar run.jar`. 

== Conclusão

Ao utilizar o xref:#modelo[modelo] _Dockerfile_ proposto neste artigo, você será capaz de empacotar ser projeto _Kotlin_ com _Gradle_ em um contêiner _Docker_. Qualquer dúvida ou sugestão peço, por gentileza que entre em contato comigo em uma das minhas redes sociais.

Até a próxima!