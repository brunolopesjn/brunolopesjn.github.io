---
title: "Configurando Micronaut Framework na Unha"
date: 2023-10-21T22:54:21-03:00
draft: false

author: "Bruno Lopes"
categories: [Kotlin]
tags: [Kotlin, Micronaut]
featuredImage: "/img/20231021-configurando-micronaut-framework-na-unha.svg"
featuredImagePreview: "/img/20231021-configurando-micronaut-framework-na-unha.svg"
---

:source-highlighter: rouge

O _Micronaut_ é um _framework full stack Java_ moderno, baseado na JVM e projetado para construir aplicações JVM modulares e que sejam facilmente testáveis. O _framework_ fornece suporte para as linguagens de programação *Java*, *Kotlin* e *Groovy*.

Foi desenvolvido pelas mesmas pessoas que criaram o _Grails framework_ e se inspira em lições aprendidas ao longo dos anos construindo aplicativos do mundo real, de monólitos a microsserviços usando Spring, Spring Boot e Grails.

O _Micronaut_ oferece, por padrão, duas formas de criar uma aplicação:

* Através de uma https://docs.micronaut.io/latest/guide/#buildCLI[ferramenta de CLI]
* Através de uma ferramenta online de criação de projetos, chamada de https://micronaut.io/launch/[_Micronaut Launch_]

Particularmente não gosto da forma como uma aplicação _Micronaut_ é criada por essas ferramentas pois os arquivos de configuração _gradle_ são complexos (várias ferramentas e bibliotecas configuradas) e pouco documentado (gosto de ter o controle do que está sendo configurado e porque). Prefiro criar um projeto Kotlin do zero e configurar manualmente o necessário para o _Micronaut_ funcionar.

Deste modo, o objetivo desta postagem é justamente descrever como configurar o _Micronaut_ a partir de um projeto _Kotlin_ criado do zero via _IntelliJ IDEA Community Edition_.

== Criando o Projeto Kotlin

Partindo da premissa que você já possua o _OpenJDK_ e o _IntelliJ IDEA Community Edition_ devidamente configurados, abra o _IntelliJ_ e na tela principal clique no botão *New Project*

image::/img/configurando-micronaut-na-unha-01.png[Tela inicial do IntelliJ com um retângulo transparente e com bordas na cor vermelha sobre o botão New Project]

Após clicar no botão *New Project*, será exibida uma janela para preencher um formulário com os dados no novo projeto. Os seguintes valores foram utilizados:

* O campo _Name_ foi preenchido com o valor *sample*
* No campo _Language_ foi selecionado a opção *Kotlin*
* No campo _Build System_ foi selecionado a opção *Gradle*
* No campo _JDK_ selecione a versão do JDK a ser utilizada (nesta postagem foi utilizado o _OpenJDK 17_)
* No campo _Gradle DSL_ foi selecionado a opção *Kotlin*
* Em _Advanced Settings_ foi preenchido da seguinte maneira:
** O campo _GroupId_ foi preenchido com o valor *br.dev.profbrunolopes* (ajuste esse valor conforme o domínio reverso utilizado em suas aplicações)
** O campo _ArtifactId_ foi preenchido com o valor *sample* (geralmente utiliza-se o mesmo valor utilizado no campo _Name_)

A imagem abaixo exibe os campos do formulário de criação de um projeto configurado conforme descrito anteriormente.

image::/img/configurando-micronaut-na-unha-02.png[Tela de criação de um novo projeto no IntelliJ a qual apresenta um formulário com campos de texto e de seleção os quais foram preenchidos com os valores apresentados na listagem acima]

Após preencher o formulário com os devidos valores, clique no botão *Create* (canto inferior direito) e um projeto _Kotlin_ com _Gradle_ será criado.

{{< admonition type=info title="Ferramentas utilizados" open=true >}}
Foram utilizados as seguintes ferramentas durante a escrita desta postagem:

* IntelliJ IDEA Community Edition 2023.1.4
* OpenJDK 17
* Kotlin 1.9.10
* Gradle 8.3
* Micronaut 4.1.5

{{< /admonition >}}

== Configurando o Gradle

Com o projeto devidamente criado, vamos configurar o _Gradle_ editando primeiramente o arquivo `build.gradle.kts` com o conteúdo a seguir:

[source, kotlin]
----
plugins {
    kotlin("jvm") version "1.9.10"
    id("io.micronaut.application") version "4.1.2"
    id("io.micronaut.aot") version "4.1.2"
    id("com.google.devtools.ksp") version "1.9.10-1.0.13"
    id("org.jetbrains.kotlin.plugin.allopen") version "1.9.10"
}

group = "br.dev.profbrunolopes"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
}

dependencies {
    ksp("io.micronaut.serde:micronaut-serde-processor")
    ksp("io.micronaut.data:micronaut-data-processor")

    implementation("io.micronaut.kotlin:micronaut-kotlin-runtime")
    implementation("io.micronaut.serde:micronaut-serde-jackson")
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.10")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.9.10")

    runtimeOnly("ch.qos.logback:logback-classic")
    runtimeOnly("com.fasterxml.jackson.module:jackson-module-kotlin")
    testImplementation("io.micronaut:micronaut-http-client")
}

tasks {
    compileKotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }
    compileTestKotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }
}

application {
    mainClass.set("br.dev.profbrunolopes.sample.MainKt")
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

micronaut {
    version("4.1.5")
    runtime("netty")
    testRuntime("kotest5")
    processing {
        incremental(true)
        annotations("br.dev.profbrunolopes.sample*")
    }
    aot {
        optimizeServiceLoading.set(false)
        convertYamlToJava.set(false)
        precomputeOperations.set(true)
        cacheEnvironment.set(true)
        optimizeClassLoading.set(true)
        deduceEnvironment.set(true)
        optimizeNetty.set(true)
    }
}
----

Para facilitar a explicação do conteúdo do arquivo `build.gradle.kts` irei dividi-lo em seis blocos e explica-los de forma individual.

=== Bloco 1 - Seção Plugins

O primeiro bloco do `build.gradle.kts` temos a seção de _plugins_ configurados no _Gradle_:

[source, kotlin]
----
plugins {
    id("org.jetbrains.kotlin.jvm") version "1.9.10" <1>
    id("io.micronaut.application") version "4.1.2" <2>
    id("io.micronaut.aot") version "4.1.2" <3>
    id("com.google.devtools.ksp") version "1.9.10-1.0.13" <4>
    id("org.jetbrains.kotlin.plugin.allopen") version "1.9.10" <5>
    id("com.github.johnrengelman.shadow") version "8.1.1" <6>
}
----
<1> _Plugin_ do _Kotlin_ para JVM o qual define qual versão do _Kotlin_ será utilizada no projeto.
<2> _Plugin_ de construção de aplicativos _Micronaut_.
<3> _Plugin_ que integra com o _Micronaut AOT_ para produzir binários otimizados.
<4> _Plugin_ que habilita o uso do _Kotlin Symbol Processing_ (KSP) no projeto.
<5> _Plugin_ que marca certas classes e membros de classes como `open`.
<6> _Plugin_ que facilita a construção do arquivo *JAR* final do projeto.


=== Bloco 2 - GroupId, ArtifactId e Repositórios

O segundo bloco do `build.gradle.kts` temos as propriedades _group_ e _version_ e o bloco _repositories_:

[source, kotlin]
----
group = "br.dev.profbrunolopes" <1>
version = "1.0-SNAPSHOT" <2>

repositories {
    mavenCentral() <3>
}
----
<1> Definindo a propriedade _group_ do projeto com0 `br.dev.profbrunolopes`.
<2> Definindo a propriedade _version_ do projeto como `1.0-SNAPSHOT`.
<3> Define o repositório _Maven Central_ para a busca de dependências do projeto.

{{< admonition type=question title="O que significa SNAPSHOT na definição da versão?" open=true >}}
Quando é definido a versão do projeto como, por exemplo `1.0-SNAPSHOT` é uma convenção de nomenclatura comum para indicar que esta versão é uma versão em desenvolvimento (e não uma versão estável) de um projeto.

A palavra `SNAPSHOT` indica que a versão ainda está no fluxo de desenvolvimento e pode receber atualizações. Quando estiver pronto para lançar uma versão estável, geralmente removerá o sufixo `-SNAPSHOT` e poderá incrementar a versão, dependendo da sua estratégia de versionamento.
{{< /admonition >}}

=== Bloco 3 - Dependências

O terceiro bloco do `build.gradle.kts` temos a seção _dependencies_ onde estão definidas as dependências do projeto:

[source, kotlin]
----
dependencies {
    ksp("io.micronaut.serde:micronaut-serde-processor") <1>
    ksp("io.micronaut.data:micronaut-data-processor")<2>

    implementation("io.micronaut.kotlin:micronaut-kotlin-runtime") <3>
    implementation("io.micronaut.serde:micronaut-serde-jackson") <4>
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.10") <5>

    runtimeOnly("ch.qos.logback:logback-classic") <6>
    runtimeOnly("com.fasterxml.jackson.module:jackson-module-kotlin") <7>
    testImplementation("io.micronaut:micronaut-http-client") <8>
}
----
<1> Dependência do processador de símbolos _Kotlin_ (KSP) para o módulo `micronaut-serde-processor` do _Micronaut_. Este processador em particular é para serialização e deserialização no _Micronaut_.
<2> Dependência do processador de símbolos _Kotlin_ (KSP) para o módulo `micronaut-data-processor` do _Micronaut_.  Este processador é utilizado para processar anotações relacionadas ao _Micronaut_ Data, que é a camada de acesso a dados do _Micronaut_.
<3> Esta dependência fornece funcionalidades essenciais para executar aplicações _Micronaut_ escritas em Kotlin.
<4> Implementação do módulo de serialização e deserialização baseado no _Jackson_ para _Micronaut_. _Jackson_ é uma biblioteca popular para serialização e deserialização em _Java_ e _Kotlin_.
<5> Biblioteca de reflexão do _Kotlin_ ao projeto, permitindo o uso de funcionalidades de reflexão específicas do _Kotlin_.
<6> Biblioteca de _logging_ popular. Esta dependência é necessária apenas em tempo de execução.
<7> Este é um módulo _Jackson_ para suporte a _Kotlin_, permitindo que o _Jackson_ funcione bem com classes _Kotlin_, incluindo classes de dados. Assim como o _Logback_, é necessário apenas em tempo de execução.
<8> Adiciona o cliente _HTTP_ do Micronaut como uma dependência de teste. Isso significa que essa biblioteca só será utilizada durante a fase de teste e não será incluída no artefato final da aplicação.

=== Bloco 4 - Tarefas

O quarto bloco do `build.gradle.kts` temos a seção _tasks_ onde são definidas ou configuradas tarefas dentro do _Gradle_. Tarefas são ações executadas pelo _Gradle_ como, por exemplo, compilar código, executar testes ou criar artefatos:

[source, kotlin]
----
tasks {
    compileKotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17) <1>
        }
    }
    compileTestKotlin {
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17) <2>
        }
    }
}
----
<1> Aqui, você está especificando opções para o compilador _Kotlin_, definindo para qual versão da _JVM_ o código _Kotlin_ compilado será compilado. Em particular, está sendo definido como alvo a versão *17* da _JVM_.
<2> Similar ao `compileKotlin`, mas este bloco se refere à compilação do código _Kotlin_ dentro do diretório de testes do seu projeto. Está sendo aplicado as mesmas opções de compilador que definiu para o código _Kotlin_ principal.

=== Bloco 5 - Aplicação e Java

O quinto bloco do `build.gradle.kts` temos as seções _application_ e _java_:

[source, kotlin]
----
application {
    mainClass.set("br.dev.profbrunolopes.sample.MainKt") <1>
}

java {
    sourceCompatibility = JavaVersion.toVersion("17") <2>
}
----
<1> Definindo a classe principal (_mainClass_) da sua aplicação. Esta é a classe que contém o método `main()` que será invocado quando a aplicação for iniciada.
<2> Define a versão da linguagem _Java_ para compilar o projeto. Aqui, está sendo definido a compatibilidade de origem para a versão _Java 17_, o que significa que o código _Java_ escrito para este projeto deve aderir às características e regras da versão _17 do Java_.

=== Bloco 6 - Micronaut

O sexto e último bloco do `build.gradle.kts` temos a seção _micronaut_ que é responsável por configurar as especificações do _Micronaut_ no projeto:

[source, kotlin]
----
micronaut {
    version("4.1.2") <1>
    runtime("netty") <2>
    testRuntime("kotest5") <3>
    processing {
        incremental(true) <4>
        annotations("br.dev.profbrunolopes.sample*") <5>
    }
    aot {
        optimizeServiceLoading.set(false) <6>
        convertYamlToJava.set(false) <7>
        precomputeOperations.set(true) <8>
        cacheEnvironment.set(true) <9>
        optimizeClassLoading.set(true) <10>
        deduceEnvironment.set(true) <11>
        optimizeNetty.set(true) <12>
    }
}
----
<1> Define a versão do _Micronaut_ que será utilizada no projeto.
<2> Define qual servidor de aplicação será utilizado para executar a aplicação _Micronaut_. *Netty* é um servidor _web_ e _framework_ de rede assíncrona. _Micronaut_ suporta várias opções de _runtime_, e *netty* é uma das mais populares.
<3> Define a biblioteca de teste que será utilizada em tempo de teste. *Kotest* é uma moderna biblioteca de testes para _Kotlin_.
<4> Habilita o processamento incremental de anotações. Isso pode melhorar os tempos de compilação, pois só processa as alterações desde a última compilação, ao invés de processar tudo novamente.
<5> Define quais anotações serão processadas. Aqui, você está especificando que todas as anotações no pacote `br.dev.profbrunolopes.sample` (e subpacotes) serão processadas.
<6> Define se a otimização de carregamento de serviço deve ser habilitada.
<7> Decide se as configurações em _YAML_ devem ser convertidas para propriedades _Java_ em tempo de compilação.
<8> Habilita/desabilita a pré-computação de operações.
<9> Define se o ambiente deve ser cacheado.
<10> Habilita a otimização de carregamento de classes.
<11> Define se o ambiente deve ser deduzido.
<12> Habilita otimizações específicas para o _Netty_.

== Criando um Controller

Nesse ponto temos configurado o _Micronaut_ em nosso projeto, podemos criar um controlador no nosso projeto. 

Vamos criar o pacote `br.dev.profbrunolopes.sample` e mover o arquivo `Main.kt` para dentro do mesmo. Em seguida, vamos criar a classe `HelloController` dentro do pacote `br.dev.profbrunolopes.sample` com o seguinte conteúdo:

[source, kotlin]
----
package br.dev.profbrunolopes.sample

import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get

@Controller("/hello") <1>
class HelloController {

    @Get() <2>
    fun hello(): String {
        return "Hello world!" <3>
    }

}
----
<1> A anotação `@Controller` define a classe como um controlador mapeado para o caminho */hello*.
<2> A anotação `@Get` mapeia o método *hello* para todas as solicitações que usam um `HTTP GET`.
<3> Uma _String_ "Hello World" é retornada como resposta.

== Criando o ponto de inicialização da aplicação

Vamos editar o arquivo `Main.kt` com o seguinte conteúdo:

[source, kotlin]
----
package br.dev.profbrunolopes.sample

import io.micronaut.runtime.Micronaut

fun main(args: Array<String>) {
    Micronaut.run(*args)
}
----

No código acima estamos definindo a função `main`, a qual será invocada quando a aplicação for inicializada e executando o método estático `Micronaut.run(*args)` para inicializar o Micronaut.

{{< admonition type=info title="Operador de espalhamento" open=true >}}
O operador de espalhamento (ou `spread operator`) é utilizado para desempacotar um _array_.

Quando você possui uma função que aceita *varargs* e você deseja passar um array para esta função, você deve utilizar o operador de espalhamento.
{{< /admonition >}}

== Criando arquivos de configuração de log e da aplicação

O *Logback* é um sistema de _logging_ que pretende ser um sucessor ao veterano de guerra _log4j_. Para configurar corretamente o *Logback* vamos adicionar o arquivo `logback.xml` dentro da pasta resources com o seguinte conteúdo:

[source, xml]
----
<configuration>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %cyan(%d{HH:mm:ss.SSS}) %gray([%thread]) %highlight(%-5level) %magenta(%logger{36}) - %msg%n
            </pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="STDOUT" />
    </root>

</configuration>
----

O _Micronaut_ fornece um mecanismo flexível que permite ler configurações da aplicação através de arquivos de configuração específicos. Não iremos entrar em detalhes das possibilidades de configuração (isto está fora do escopo desta postagem) mas iremos criar o arquivo `application.properties` com o seguinte conteúdo:

[source, text]
----
micronaut.application.name=sample <1>
----
<1> Propriedade de configuração do _Micronaut_ que define o nome da aplicação

== Iniciando a aplicação

Após realizar todas as etapas anteriores, seu projeto deve apresentar a seguinte estrutura de pacote e de arquivos.

image::/img/configurando-micronaut-na-unha-03.png[Estrutura do projeto após a criação do pacote, controlador, arquivo main, arquivo de configuração do logback e do arquivo de configuração da aplicação]

Para inicializar a aplicação, basta abrir o arquivo `Main.kt` e clicar no simbolo de _play_ que está no lado esquerdo  da função `main` e, em seguida, clicar em `Run Main.kt`. A aplicação será inicializada e a seguinte saída será mostrada:

image::/img/configurando-micronaut-na-unha-04.png[Saída do terminal ao iniciar a aplicação Micronaut]

== Conclusão

Nesta postagem foi mostrado como configurar uma aplicação _Micronaut_ a partir de um projeto Kotlin criado via _IntelliJ IDEA CE_. A partir deste projeto base, pode-se evoluir para configurações mais complexas do _Micronaut_ como, por exemplo, adicionar o suporte a persistência de dados, mecanismos de segurança e etc.
